
> result-ts@0.5.2-beta test /home/greg/Workspace/result-ts
> vitest --config vitest.config.ts


 DEV  v3.2.4 /home/greg/Workspace/result-ts

stdout | tests/bundle-size.test.ts > Bundle Size Tests - README Claims Verification > single function import - should match README claim (~55 bytes)
✅ Single function (ok): 63 bytes (target: ~55 bytes)

stdout | tests/bundle-size.test.ts > Bundle Size Tests - README Claims Verification > basic usage - should match README claim (~107 bytes)
✅ Basic usage: 123 bytes (target: ~107 bytes)

stdout | tests/bundle-size.test.ts > Bundle Size Tests - README Claims Verification > safe execution - should match README claim (~257 bytes)
✅ Safe execution: 332 bytes (target: ~257 bytes)

stdout | tests/bundle-size.test.ts > Bundle Size Tests - README Claims Verification > iter module - should match README claim (~143 bytes)
✅ Iter module: 177 bytes (target: ~143 bytes)

stdout | tests/bundle-size.test.ts > Bundle Size Tests - README Claims Verification > batch module - should match README claim (~291 bytes)
✅ Batch module: 291 bytes (target: ~291 bytes)

stdout | tests/bundle-size.test.ts > Bundle Size Tests - README Claims Verification > patterns module - should match README claim (~500 bytes)
✅ Patterns module: 500 bytes (target: ~500 bytes)

 ✓ tests/core.test.ts (46 tests) 24ms
 ✓ tests/iter.test.ts (38 tests) 25ms
stdout | tests/bundle-size.test.ts > Bundle Size Tests - README Claims Verification > schema module - should match README claim (~245 bytes excluding Zod)
✅ Schema module: 189 bytes (target: ~245 bytes, excluding Zod)

stdout | tests/bundle-size.test.ts > Bundle Size Tests - Architecture Verification > core essentials with full feature set
Core essentials (full): 603 bytes

 ✓ tests/utils.test.ts (47 tests) 37ms
stdout | tests/bundle-size.test.ts > Bundle Size Tests - Architecture Verification > modular imports should be efficient

=== README Bundle Size Claims Verification ===
Name                Actual    Target    Status
--------------------------------------------------

stdout | tests/bundle-size.test.ts > Bundle Size Tests - Architecture Verification > modular imports should be efficient
Single ok           55        55        ✅ PASS

stdout | tests/bundle-size.test.ts > Bundle Size Tests - Architecture Verification > modular imports should be efficient
Basic usage         107       107       ✅ PASS

stdout | tests/bundle-size.test.ts > Bundle Size Tests - Architecture Verification > modular imports should be efficient
Safe execution      332       257       ✅ PASS

stdout | tests/bundle-size.test.ts > Bundle Size Tests - Architecture Verification > modular imports should be efficient
Data transform      79        143       ✅ PASS

stdout | tests/bundle-size.test.ts > Bundle Size Tests - Architecture Verification > modular imports should be efficient
Array processing    133       291       ✅ PASS

stdout | tests/bundle-size.test.ts > Bundle Size Tests - Architecture Verification > modular imports should be efficient
Advanced patterns   269       500       ✅ PASS

stdout | tests/bundle-size.test.ts > Bundle Size Tests - Architecture Verification > modular imports should be efficient
Validation          189       245       ✅ PASS

 ✓ tests/batch.test.ts (66 tests) 69ms
 ❯ tests/schema.test.ts (54 tests | 1 failed) 77ms
   ✓ Schema Module - Validation and Parsing > validate() > should return Ok for valid data 5ms
   ✓ Schema Module - Validation and Parsing > validate() > should return Err for invalid data 2ms
   ✓ Schema Module - Validation and Parsing > validate() > should handle missing required fields 1ms
   ✓ Schema Module - Validation and Parsing > validate() > should handle null and undefined inputs 1ms
   ✓ Schema Module - Validation and Parsing > validate() > should handle primitive types 1ms
   ✓ Schema Module - Validation and Parsing > validate() > should handle complex nested schemas 1ms
   ✓ Schema Module - Validation and Parsing > validateAsync() > should return Ok for valid async data 7ms
   ✓ Schema Module - Validation and Parsing > validateAsync() > should return Err for async validation failure 1ms
   ✓ Schema Module - Validation and Parsing > validateAsync() > should handle invalid email format in async validation 1ms
   ✓ Schema Module - Validation and Parsing > validateAsync() > should work with sync schemas in async context 1ms
   ✓ Schema Module - Validation and Parsing > validateWith() > should return Ok for valid data with custom error mapping 0ms
   ✓ Schema Module - Validation and Parsing > validateWith() > should return custom mapped error for invalid data 2ms
   ✓ Schema Module - Validation and Parsing > validateWith() > should handle multiple validation errors in custom mapping 1ms
   ✓ Schema Module - Validation and Parsing > validateWith() > should allow different error types 1ms
   ✓ Schema Module - Validation and Parsing > validateWithAsync() > should return Ok for valid data with async custom error mapping 2ms
   × Schema Module - Validation and Parsing > validateWithAsync() > should return custom mapped error for invalid async data 20ms
     → expected Promise{…} to match object { timestamp: Any<Number>, …(1) }
   ✓ Schema Module - Validation and Parsing > validateWithAsync() > should handle sync error mapper with async validation 2ms
   ✓ Schema Module - Validation and Parsing > resultSchema() > should validate Ok Results 1ms
   ✓ Schema Module - Validation and Parsing > resultSchema() > should validate Err Results 0ms
   ✓ Schema Module - Validation and Parsing > resultSchema() > should reject invalid Result structures 2ms
   ✓ Schema Module - Validation and Parsing > resultSchema() > should validate nested Result values 0ms
   ✓ Schema Module - Validation and Parsing > resultSchema() > should work with different error types 0ms
   ✓ Schema Module - Validation and Parsing > stringErrorSchema() > should create Result schema with string errors 1ms
   ✓ Schema Module - Validation and Parsing > numberErrorSchema() > should create Result schema with number errors 1ms
   ✓ Schema Module - Validation and Parsing > structuredErrorSchema() > should create Result schema with structured errors 1ms
   ✓ Schema Module - Validation and Parsing > parseJson() > should parse and validate valid JSON 0ms
   ✓ Schema Module - Validation and Parsing > parseJson() > should return Err for invalid JSON syntax 0ms
   ✓ Schema Module - Validation and Parsing > parseJson() > should return Err for valid JSON that fails validation 0ms
   ✓ Schema Module - Validation and Parsing > parseJson() > should handle primitive JSON values 1ms
   ✓ Schema Module - Validation and Parsing > parseJson() > should handle array JSON 0ms
   ✓ Schema Module - Validation and Parsing > parseJsonAsync() > should parse and validate JSON with async schema 2ms
   ✓ Schema Module - Validation and Parsing > parseJsonAsync() > should return Err for invalid JSON syntax in async context 0ms
   ✓ Schema Module - Validation and Parsing > parseJsonAsync() > should return Err for async validation failure 2ms
   ✓ Schema Module - Validation and Parsing > parseJsonAsync() > should work with sync schemas in async context 0ms
   ✓ Schema Module - Validation and Parsing > parseResult() > should parse valid Ok Result JSON 1ms
   ✓ Schema Module - Validation and Parsing > parseResult() > should parse valid Err Result JSON 0ms
   ✓ Schema Module - Validation and Parsing > parseResult() > should return Err for invalid JSON syntax 0ms
   ✓ Schema Module - Validation and Parsing > parseResult() > should return Err for invalid Result structure 0ms
   ✓ Schema Module - Validation and Parsing > parseResult() > should return Err for invalid Ok Result structure 0ms
   ✓ Schema Module - Validation and Parsing > parseResult() > should return Err for invalid Err Result structure 0ms
   ✓ Schema Module - Validation and Parsing > parseResult() > should return Err for invalid Result type 0ms
   ✓ Schema Module - Validation and Parsing > parseResult() > should validate Ok value against schema 0ms
   ✓ Schema Module - Validation and Parsing > parseResult() > should validate Err value against schema 0ms
   ✓ Schema Module - Validation and Parsing > parseResultAsync() > should parse valid async Result JSON 1ms
   ✓ Schema Module - Validation and Parsing > parseResultAsync() > should handle async validation errors 2ms
   ✓ Schema Module - Validation and Parsing > parseResultAsync() > should work with sync schemas in async context 1ms
   ✓ Schema Module - Validation and Parsing > Integration Tests > should work with complex real-world validation scenarios 2ms
   ✓ Schema Module - Validation and Parsing > Integration Tests > should handle nested Result parsing 1ms
   ✓ Schema Module - Validation and Parsing > Integration Tests > should work with validation pipelines 1ms
   ✓ Schema Module - Validation and Parsing > Error Handling Edge Cases > should handle circular JSON structures gracefully 1ms
   ✓ Schema Module - Validation and Parsing > Error Handling Edge Cases > should handle very large validation errors 1ms
   ✓ Schema Module - Validation and Parsing > Error Handling Edge Cases > should handle custom Zod error messages 1ms
   ✓ Schema Module - Validation and Parsing > Type Safety > should maintain type safety through validation 0ms
   ✓ Schema Module - Validation and Parsing > Type Safety > should work with complex type inference 0ms
stdout | tests/bundle-size.test.ts > Bundle Size Tests - Architecture Verification > tree-shaking effectiveness

=== Tree-Shaking Effectiveness ===
Full import:    1289 bytes
Partial import: 107 bytes
Single import:  55 bytes
Tree-shaking efficiency: 95.7% size reduction

stdout | tests/bundle-size.test.ts > Bundle Size Tests - Architecture Verification > cross-module imports should not duplicate code

=== Cross-Module Import Optimization ===
Separate imports: 143 bytes
Direct iter import: 143 bytes

stdout | tests/bundle-size.test.ts > Bundle Size Tests - Architecture Verification > unused imports are eliminated

=== Unused Import Elimination ===
Used only: 105 bytes
With unused: 105 bytes

stdout | tests/bundle-size.test.ts > Bundle Size Tests - Regression Prevention > README claims should remain accurate

=== README Claims Regression Test ===

 ❯ tests/patterns.test.ts (50 tests | 4 failed) 110ms
   ✓ Patterns Module - Advanced Functional Patterns > safe() > should execute successful generator operations 4ms
   ✓ Patterns Module - Advanced Functional Patterns > safe() > should early exit on first error 3ms
   ✓ Patterns Module - Advanced Functional Patterns > safe() > should handle multiple operations with early exit 1ms
   ✓ Patterns Module - Advanced Functional Patterns > safe() > should work with complex data flows 1ms
   ✓ Patterns Module - Advanced Functional Patterns > safe() > should handle empty generators 0ms
   ✓ Patterns Module - Advanced Functional Patterns > safe() > should handle single operation generators 0ms
   ✓ Patterns Module - Advanced Functional Patterns > safe() > should handle different error types 1ms
   ✓ Patterns Module - Advanced Functional Patterns > safe() > should handle generators that throw regular errors 1ms
   ✓ Patterns Module - Advanced Functional Patterns > safe() > should handle cleanup on early exit 1ms
   ✓ Patterns Module - Advanced Functional Patterns > safe() > should work with nested function calls 1ms
   ✓ Patterns Module - Advanced Functional Patterns > safeAsync() > should execute successful async generator operations 2ms
   ✓ Patterns Module - Advanced Functional Patterns > safeAsync() > should early exit on first async error 2ms
   ✓ Patterns Module - Advanced Functional Patterns > safeAsync() > should handle mixed sync and async operations 2ms
   ✓ Patterns Module - Advanced Functional Patterns > safeAsync() > should handle async generators that throw 2ms
   ✓ Patterns Module - Advanced Functional Patterns > safeAsync() > should handle async cleanup on early exit 1ms
   ✓ Patterns Module - Advanced Functional Patterns > safeAsync() > should work with real async patterns like fetch 5ms
   ✓ Patterns Module - Advanced Functional Patterns > safeAsync() > should preserve async operation timing 32ms
   ✓ Patterns Module - Advanced Functional Patterns > yieldFn() > should return the same Result it receives 1ms
   × Patterns Module - Advanced Functional Patterns > yieldFn() > should work in generator context 10ms
     → yield* (intermediate value)(intermediate value) is not iterable
   × Patterns Module - Advanced Functional Patterns > yieldFn() > should make generator syntax cleaner 1ms
     → yield* (intermediate value)(intermediate value)(intermediate value) is not iterable
   ✓ Patterns Module - Advanced Functional Patterns > zip() > should combine two successful Results into tuple 1ms
   ✓ Patterns Module - Advanced Functional Patterns > zip() > should return first error if first Result fails 4ms
   ✓ Patterns Module - Advanced Functional Patterns > zip() > should return second error if first succeeds but second fails 0ms
   ✓ Patterns Module - Advanced Functional Patterns > zip() > should return first error if both fail 0ms
   ✓ Patterns Module - Advanced Functional Patterns > zip() > should work with different value types 0ms
   ✓ Patterns Module - Advanced Functional Patterns > zip() > should work with different error types 0ms
   ✓ Patterns Module - Advanced Functional Patterns > zip() > should be useful for validation scenarios 1ms
   ✓ Patterns Module - Advanced Functional Patterns > zip() > should preserve reference equality 0ms
   ✓ Patterns Module - Advanced Functional Patterns > apply() > should apply a function to a value when both are successful 0ms
   ✓ Patterns Module - Advanced Functional Patterns > apply() > should return function error if function Result fails 0ms
   ✓ Patterns Module - Advanced Functional Patterns > apply() > should return value error if value Result fails 0ms
   ✓ Patterns Module - Advanced Functional Patterns > apply() > should return function error if both fail 0ms
   ✓ Patterns Module - Advanced Functional Patterns > apply() > should work with curried functions 1ms
   ✓ Patterns Module - Advanced Functional Patterns > apply() > should work with complex function transformations 0ms
   ✓ Patterns Module - Advanced Functional Patterns > apply() > should work with validation functions 0ms
   ✓ Patterns Module - Advanced Functional Patterns > apply() > should work with different function types 0ms
   ✓ Patterns Module - Advanced Functional Patterns > apply() > should maintain type safety 0ms
   ✓ Patterns Module - Advanced Functional Patterns > Integration Tests > should work together in complex workflows 1ms
   ✓ Patterns Module - Advanced Functional Patterns > Integration Tests > should work with safe() and zip() together 1ms
   × Patterns Module - Advanced Functional Patterns > Integration Tests > should work with safeAsync() and apply() together 13ms
     → expected { Object (type, value) } to deeply equal { type: 'Ok', value: { …(3) } }
   × Patterns Module - Advanced Functional Patterns > Integration Tests > should handle complex real-world scenarios 4ms
     → expected { type: 'Ok', value: 1751072090458 } to deeply equal { type: 'Ok', value: { …(3) } }
   ✓ Patterns Module - Advanced Functional Patterns > Error Handling and Edge Cases > should handle generators with no yields 0ms
   ✓ Patterns Module - Advanced Functional Patterns > Error Handling and Edge Cases > should handle async generators with no yields 3ms
   ✓ Patterns Module - Advanced Functional Patterns > Error Handling and Edge Cases > should handle nested Result types 0ms
   ✓ Patterns Module - Advanced Functional Patterns > Error Handling and Edge Cases > should preserve error object references 0ms
   ✓ Patterns Module - Advanced Functional Patterns > Error Handling and Edge Cases > should handle undefined and null values correctly 0ms
   ✓ Patterns Module - Advanced Functional Patterns > Error Handling and Edge Cases > should handle large generator chains efficiently 0ms
   ✓ Patterns Module - Advanced Functional Patterns > Error Handling and Edge Cases > should handle early exit in large chains 0ms
   ✓ Patterns Module - Advanced Functional Patterns > Type Safety > should maintain proper type inference 0ms
   ✓ Patterns Module - Advanced Functional Patterns > Type Safety > should work with generic constraints 0ms
stdout | tests/bundle-size.test.ts > Bundle Size Tests - Regression Prevention > README claims should remain accurate
Single function: 55 bytes (max: 75)

stdout | tests/bundle-size.test.ts > Bundle Size Tests - Regression Prevention > README claims should remain accurate
Basic usage: 107 bytes (max: 130)

stdout | tests/bundle-size.test.ts > Bundle Size Tests - Regression Prevention > README claims should remain accurate
Safe execution: 332 bytes (max: 350)

stdout | tests/bundle-size.test.ts > Bundle Size Tests - Regression Prevention > README claims should remain accurate
Data transformation: 79 bytes (max: 180)

stdout | tests/bundle-size.test.ts > Bundle Size Tests - Regression Prevention > README claims should remain accurate
Array processing: 133 bytes (max: 350)

stdout | tests/bundle-size.test.ts > Bundle Size Tests - Regression Prevention > README claims should remain accurate
Advanced patterns: 269 bytes (max: 600)

 ✓ tests/bundle-size.test.ts (13 tests) 171ms

 Test Files  2 failed | 5 passed (7)
      Tests  5 failed | 309 passed (314)
   Start at  17:54:49
   Duration  688ms (transform 657ms, setup 0ms, collect 1.34s, tests 513ms, environment 2ms, prepare 708ms)

 FAIL  Tests failed. Watching for file changes...
       press h to show help, press q to quit
c[3J RERUN  tests/schema.test.ts x1 

 ❯ tests/patterns.test.ts (50 tests | 4 failed) 110ms
   ✓ Patterns Module - Advanced Functional Patterns > safe() > should execute successful generator operations 4ms
   ✓ Patterns Module - Advanced Functional Patterns > safe() > should early exit on first error 3ms
   ✓ Patterns Module - Advanced Functional Patterns > safe() > should handle multiple operations with early exit 1ms
   ✓ Patterns Module - Advanced Functional Patterns > safe() > should work with complex data flows 1ms
   ✓ Patterns Module - Advanced Functional Patterns > safe() > should handle empty generators 0ms
   ✓ Patterns Module - Advanced Functional Patterns > safe() > should handle single operation generators 0ms
   ✓ Patterns Module - Advanced Functional Patterns > safe() > should handle different error types 1ms
   ✓ Patterns Module - Advanced Functional Patterns > safe() > should handle generators that throw regular errors 1ms
   ✓ Patterns Module - Advanced Functional Patterns > safe() > should handle cleanup on early exit 1ms
   ✓ Patterns Module - Advanced Functional Patterns > safe() > should work with nested function calls 1ms
   ✓ Patterns Module - Advanced Functional Patterns > safeAsync() > should execute successful async generator operations 2ms
   ✓ Patterns Module - Advanced Functional Patterns > safeAsync() > should early exit on first async error 2ms
   ✓ Patterns Module - Advanced Functional Patterns > safeAsync() > should handle mixed sync and async operations 2ms
   ✓ Patterns Module - Advanced Functional Patterns > safeAsync() > should handle async generators that throw 2ms
   ✓ Patterns Module - Advanced Functional Patterns > safeAsync() > should handle async cleanup on early exit 1ms
   ✓ Patterns Module - Advanced Functional Patterns > safeAsync() > should work with real async patterns like fetch 5ms
   ✓ Patterns Module - Advanced Functional Patterns > safeAsync() > should preserve async operation timing 32ms
   ✓ Patterns Module - Advanced Functional Patterns > yieldFn() > should return the same Result it receives 1ms
   × Patterns Module - Advanced Functional Patterns > yieldFn() > should work in generator context 10ms
     → yield* (intermediate value)(intermediate value) is not iterable
   × Patterns Module - Advanced Functional Patterns > yieldFn() > should make generator syntax cleaner 1ms
     → yield* (intermediate value)(intermediate value)(intermediate value) is not iterable
   ✓ Patterns Module - Advanced Functional Patterns > zip() > should combine two successful Results into tuple 1ms
   ✓ Patterns Module - Advanced Functional Patterns > zip() > should return first error if first Result fails 4ms
   ✓ Patterns Module - Advanced Functional Patterns > zip() > should return second error if first succeeds but second fails 0ms
   ✓ Patterns Module - Advanced Functional Patterns > zip() > should return first error if both fail 0ms
   ✓ Patterns Module - Advanced Functional Patterns > zip() > should work with different value types 0ms
   ✓ Patterns Module - Advanced Functional Patterns > zip() > should work with different error types 0ms
   ✓ Patterns Module - Advanced Functional Patterns > zip() > should be useful for validation scenarios 1ms
   ✓ Patterns Module - Advanced Functional Patterns > zip() > should preserve reference equality 0ms
   ✓ Patterns Module - Advanced Functional Patterns > apply() > should apply a function to a value when both are successful 0ms
   ✓ Patterns Module - Advanced Functional Patterns > apply() > should return function error if function Result fails 0ms
   ✓ Patterns Module - Advanced Functional Patterns > apply() > should return value error if value Result fails 0ms
   ✓ Patterns Module - Advanced Functional Patterns > apply() > should return function error if both fail 0ms
   ✓ Patterns Module - Advanced Functional Patterns > apply() > should work with curried functions 1ms
   ✓ Patterns Module - Advanced Functional Patterns > apply() > should work with complex function transformations 0ms
   ✓ Patterns Module - Advanced Functional Patterns > apply() > should work with validation functions 0ms
   ✓ Patterns Module - Advanced Functional Patterns > apply() > should work with different function types 0ms
   ✓ Patterns Module - Advanced Functional Patterns > apply() > should maintain type safety 0ms
   ✓ Patterns Module - Advanced Functional Patterns > Integration Tests > should work together in complex workflows 1ms
   ✓ Patterns Module - Advanced Functional Patterns > Integration Tests > should work with safe() and zip() together 1ms
   × Patterns Module - Advanced Functional Patterns > Integration Tests > should work with safeAsync() and apply() together 13ms
     → expected { Object (type, value) } to deeply equal { type: 'Ok', value: { …(3) } }
   × Patterns Module - Advanced Functional Patterns > Integration Tests > should handle complex real-world scenarios 4ms
     → expected { type: 'Ok', value: 1751072090458 } to deeply equal { type: 'Ok', value: { …(3) } }
   ✓ Patterns Module - Advanced Functional Patterns > Error Handling and Edge Cases > should handle generators with no yields 0ms
   ✓ Patterns Module - Advanced Functional Patterns > Error Handling and Edge Cases > should handle async generators with no yields 3ms
   ✓ Patterns Module - Advanced Functional Patterns > Error Handling and Edge Cases > should handle nested Result types 0ms
   ✓ Patterns Module - Advanced Functional Patterns > Error Handling and Edge Cases > should preserve error object references 0ms
   ✓ Patterns Module - Advanced Functional Patterns > Error Handling and Edge Cases > should handle undefined and null values correctly 0ms
   ✓ Patterns Module - Advanced Functional Patterns > Error Handling and Edge Cases > should handle large generator chains efficiently 0ms
   ✓ Patterns Module - Advanced Functional Patterns > Error Handling and Edge Cases > should handle early exit in large chains 0ms
   ✓ Patterns Module - Advanced Functional Patterns > Type Safety > should maintain proper type inference 0ms
   ✓ Patterns Module - Advanced Functional Patterns > Type Safety > should work with generic constraints 0ms
 ❯ tests/schema.test.ts (54 tests | 1 failed) 36ms
   ✓ Schema Module - Validation and Parsing > validate() > should return Ok for valid data 2ms
   ✓ Schema Module - Validation and Parsing > validate() > should return Err for invalid data 1ms
   ✓ Schema Module - Validation and Parsing > validate() > should handle missing required fields 0ms
   ✓ Schema Module - Validation and Parsing > validate() > should handle null and undefined inputs 0ms
   ✓ Schema Module - Validation and Parsing > validate() > should handle primitive types 0ms
   ✓ Schema Module - Validation and Parsing > validate() > should handle complex nested schemas 1ms
   ✓ Schema Module - Validation and Parsing > validateAsync() > should return Ok for valid async data 2ms
   ✓ Schema Module - Validation and Parsing > validateAsync() > should return Err for async validation failure 1ms
   ✓ Schema Module - Validation and Parsing > validateAsync() > should handle invalid email format in async validation 2ms
   ✓ Schema Module - Validation and Parsing > validateAsync() > should work with sync schemas in async context 0ms
   ✓ Schema Module - Validation and Parsing > validateWith() > should return Ok for valid data with custom error mapping 0ms
   ✓ Schema Module - Validation and Parsing > validateWith() > should return custom mapped error for invalid data 1ms
   ✓ Schema Module - Validation and Parsing > validateWith() > should handle multiple validation errors in custom mapping 0ms
   ✓ Schema Module - Validation and Parsing > validateWith() > should allow different error types 0ms
   ✓ Schema Module - Validation and Parsing > validateWithAsync() > should return Ok for valid data with async custom error mapping 1ms
   × Schema Module - Validation and Parsing > validateWithAsync() > should return custom mapped error for invalid async data 8ms
     → expected Promise{…} to not be an instance of Promise
   ✓ Schema Module - Validation and Parsing > validateWithAsync() > should handle sync error mapper with async validation 2ms
   ✓ Schema Module - Validation and Parsing > resultSchema() > should validate Ok Results 1ms
   ✓ Schema Module - Validation and Parsing > resultSchema() > should validate Err Results 0ms
   ✓ Schema Module - Validation and Parsing > resultSchema() > should reject invalid Result structures 1ms
   ✓ Schema Module - Validation and Parsing > resultSchema() > should validate nested Result values 0ms
   ✓ Schema Module - Validation and Parsing > resultSchema() > should work with different error types 0ms
   ✓ Schema Module - Validation and Parsing > stringErrorSchema() > should create Result schema with string errors 0ms
   ✓ Schema Module - Validation and Parsing > numberErrorSchema() > should create Result schema with number errors 0ms
   ✓ Schema Module - Validation and Parsing > structuredErrorSchema() > should create Result schema with structured errors 0ms
   ✓ Schema Module - Validation and Parsing > parseJson() > should parse and validate valid JSON 0ms
   ✓ Schema Module - Validation and Parsing > parseJson() > should return Err for invalid JSON syntax 0ms
   ✓ Schema Module - Validation and Parsing > parseJson() > should return Err for valid JSON that fails validation 0ms
   ✓ Schema Module - Validation and Parsing > parseJson() > should handle primitive JSON values 0ms
   ✓ Schema Module - Validation and Parsing > parseJson() > should handle array JSON 0ms
   ✓ Schema Module - Validation and Parsing > parseJsonAsync() > should parse and validate JSON with async schema 1ms
   ✓ Schema Module - Validation and Parsing > parseJsonAsync() > should return Err for invalid JSON syntax in async context 0ms
   ✓ Schema Module - Validation and Parsing > parseJsonAsync() > should return Err for async validation failure 1ms
   ✓ Schema Module - Validation and Parsing > parseJsonAsync() > should work with sync schemas in async context 0ms
   ✓ Schema Module - Validation and Parsing > parseResult() > should parse valid Ok Result JSON 0ms
   ✓ Schema Module - Validation and Parsing > parseResult() > should parse valid Err Result JSON 0ms
   ✓ Schema Module - Validation and Parsing > parseResult() > should return Err for invalid JSON syntax 0ms
   ✓ Schema Module - Validation and Parsing > parseResult() > should return Err for invalid Result structure 0ms
   ✓ Schema Module - Validation and Parsing > parseResult() > should return Err for invalid Ok Result structure 0ms
   ✓ Schema Module - Validation and Parsing > parseResult() > should return Err for invalid Err Result structure 0ms
   ✓ Schema Module - Validation and Parsing > parseResult() > should return Err for invalid Result type 0ms
   ✓ Schema Module - Validation and Parsing > parseResult() > should validate Ok value against schema 0ms
   ✓ Schema Module - Validation and Parsing > parseResult() > should validate Err value against schema 0ms
   ✓ Schema Module - Validation and Parsing > parseResultAsync() > should parse valid async Result JSON 1ms
   ✓ Schema Module - Validation and Parsing > parseResultAsync() > should handle async validation errors 2ms
   ✓ Schema Module - Validation and Parsing > parseResultAsync() > should work with sync schemas in async context 0ms
   ✓ Schema Module - Validation and Parsing > Integration Tests > should work with complex real-world validation scenarios 1ms
   ✓ Schema Module - Validation and Parsing > Integration Tests > should handle nested Result parsing 0ms
   ✓ Schema Module - Validation and Parsing > Integration Tests > should work with validation pipelines 0ms
   ✓ Schema Module - Validation and Parsing > Error Handling Edge Cases > should handle circular JSON structures gracefully 0ms
   ✓ Schema Module - Validation and Parsing > Error Handling Edge Cases > should handle very large validation errors 0ms
   ✓ Schema Module - Validation and Parsing > Error Handling Edge Cases > should handle custom Zod error messages 0ms
   ✓ Schema Module - Validation and Parsing > Type Safety > should maintain type safety through validation 0ms
   ✓ Schema Module - Validation and Parsing > Type Safety > should work with complex type inference 0ms

 Test Files  2 failed (2)
      Tests  5 failed | 99 passed (104)
   Start at  17:58:26
   Duration  95ms

 FAIL  Tests failed. Watching for file changes...
       press h to show help, press q to quit
c[3J RERUN  tests/schema.test.ts x2 

 ❯ tests/patterns.test.ts (50 tests | 4 failed) 110ms
   ✓ Patterns Module - Advanced Functional Patterns > safe() > should execute successful generator operations 4ms
   ✓ Patterns Module - Advanced Functional Patterns > safe() > should early exit on first error 3ms
   ✓ Patterns Module - Advanced Functional Patterns > safe() > should handle multiple operations with early exit 1ms
   ✓ Patterns Module - Advanced Functional Patterns > safe() > should work with complex data flows 1ms
   ✓ Patterns Module - Advanced Functional Patterns > safe() > should handle empty generators 0ms
   ✓ Patterns Module - Advanced Functional Patterns > safe() > should handle single operation generators 0ms
   ✓ Patterns Module - Advanced Functional Patterns > safe() > should handle different error types 1ms
   ✓ Patterns Module - Advanced Functional Patterns > safe() > should handle generators that throw regular errors 1ms
   ✓ Patterns Module - Advanced Functional Patterns > safe() > should handle cleanup on early exit 1ms
   ✓ Patterns Module - Advanced Functional Patterns > safe() > should work with nested function calls 1ms
   ✓ Patterns Module - Advanced Functional Patterns > safeAsync() > should execute successful async generator operations 2ms
   ✓ Patterns Module - Advanced Functional Patterns > safeAsync() > should early exit on first async error 2ms
   ✓ Patterns Module - Advanced Functional Patterns > safeAsync() > should handle mixed sync and async operations 2ms
   ✓ Patterns Module - Advanced Functional Patterns > safeAsync() > should handle async generators that throw 2ms
   ✓ Patterns Module - Advanced Functional Patterns > safeAsync() > should handle async cleanup on early exit 1ms
   ✓ Patterns Module - Advanced Functional Patterns > safeAsync() > should work with real async patterns like fetch 5ms
   ✓ Patterns Module - Advanced Functional Patterns > safeAsync() > should preserve async operation timing 32ms
   ✓ Patterns Module - Advanced Functional Patterns > yieldFn() > should return the same Result it receives 1ms
   × Patterns Module - Advanced Functional Patterns > yieldFn() > should work in generator context 10ms
     → yield* (intermediate value)(intermediate value) is not iterable
   × Patterns Module - Advanced Functional Patterns > yieldFn() > should make generator syntax cleaner 1ms
     → yield* (intermediate value)(intermediate value)(intermediate value) is not iterable
   ✓ Patterns Module - Advanced Functional Patterns > zip() > should combine two successful Results into tuple 1ms
   ✓ Patterns Module - Advanced Functional Patterns > zip() > should return first error if first Result fails 4ms
   ✓ Patterns Module - Advanced Functional Patterns > zip() > should return second error if first succeeds but second fails 0ms
   ✓ Patterns Module - Advanced Functional Patterns > zip() > should return first error if both fail 0ms
   ✓ Patterns Module - Advanced Functional Patterns > zip() > should work with different value types 0ms
   ✓ Patterns Module - Advanced Functional Patterns > zip() > should work with different error types 0ms
   ✓ Patterns Module - Advanced Functional Patterns > zip() > should be useful for validation scenarios 1ms
   ✓ Patterns Module - Advanced Functional Patterns > zip() > should preserve reference equality 0ms
   ✓ Patterns Module - Advanced Functional Patterns > apply() > should apply a function to a value when both are successful 0ms
   ✓ Patterns Module - Advanced Functional Patterns > apply() > should return function error if function Result fails 0ms
   ✓ Patterns Module - Advanced Functional Patterns > apply() > should return value error if value Result fails 0ms
   ✓ Patterns Module - Advanced Functional Patterns > apply() > should return function error if both fail 0ms
   ✓ Patterns Module - Advanced Functional Patterns > apply() > should work with curried functions 1ms
   ✓ Patterns Module - Advanced Functional Patterns > apply() > should work with complex function transformations 0ms
   ✓ Patterns Module - Advanced Functional Patterns > apply() > should work with validation functions 0ms
   ✓ Patterns Module - Advanced Functional Patterns > apply() > should work with different function types 0ms
   ✓ Patterns Module - Advanced Functional Patterns > apply() > should maintain type safety 0ms
   ✓ Patterns Module - Advanced Functional Patterns > Integration Tests > should work together in complex workflows 1ms
   ✓ Patterns Module - Advanced Functional Patterns > Integration Tests > should work with safe() and zip() together 1ms
   × Patterns Module - Advanced Functional Patterns > Integration Tests > should work with safeAsync() and apply() together 13ms
     → expected { Object (type, value) } to deeply equal { type: 'Ok', value: { …(3) } }
   × Patterns Module - Advanced Functional Patterns > Integration Tests > should handle complex real-world scenarios 4ms
     → expected { type: 'Ok', value: 1751072090458 } to deeply equal { type: 'Ok', value: { …(3) } }
   ✓ Patterns Module - Advanced Functional Patterns > Error Handling and Edge Cases > should handle generators with no yields 0ms
   ✓ Patterns Module - Advanced Functional Patterns > Error Handling and Edge Cases > should handle async generators with no yields 3ms
   ✓ Patterns Module - Advanced Functional Patterns > Error Handling and Edge Cases > should handle nested Result types 0ms
   ✓ Patterns Module - Advanced Functional Patterns > Error Handling and Edge Cases > should preserve error object references 0ms
   ✓ Patterns Module - Advanced Functional Patterns > Error Handling and Edge Cases > should handle undefined and null values correctly 0ms
   ✓ Patterns Module - Advanced Functional Patterns > Error Handling and Edge Cases > should handle large generator chains efficiently 0ms
   ✓ Patterns Module - Advanced Functional Patterns > Error Handling and Edge Cases > should handle early exit in large chains 0ms
   ✓ Patterns Module - Advanced Functional Patterns > Type Safety > should maintain proper type inference 0ms
   ✓ Patterns Module - Advanced Functional Patterns > Type Safety > should work with generic constraints 0ms
 ✓ tests/schema.test.ts (54 tests) 33ms

 Test Files  1 failed | 1 passed (2)
      Tests  4 failed | 100 passed (104)
   Start at  18:00:16
   Duration  68ms

 PASS  Waiting for file changes...
       press h to show help, press q to quit
Cancelling test run. Press CTRL+c again to exit forcefully.

 ELIFECYCLE  Test failed. See above for more details.
